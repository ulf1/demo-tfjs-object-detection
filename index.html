<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Movement Detection</title>
    <style>
        body { font-family: sans-serif; text-align: center; margin-top: 2rem; }
        .container { max-width: 800px; margin: auto; }
        video, canvas { border: 1px solid #ccc; margin-top: 1rem; }
        .controls { margin: 1rem 0; }
        button { padding: 0.5rem 1rem; font-size: 1rem; cursor: pointer; }
        #status { font-weight: bold; color: green; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Record a Short Video and Detect Movement</h1>

        <div class="controls">
            <button id="startRecording">Start Recording</button>
            <button id="stopRecording" disabled>Stop Recording</button>
        </div>

        <h2>Live Camera Feed</h2>
        <video id="liveVideo" width="640" height="480" autoplay muted></video>

        <h2>Recorded Video</h2>
        <video id="recordedVideo" width="640" height="480" controls></video>
        <div id="status"></div>
        <canvas id="detectionCanvas" width="640" height="480" style="display:none;"></canvas>
        <div class="controls">
            <button id="downloadLogBtn" disabled>Download Detection Log (JSON)</button>
        </div>
    </div>

    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>

    <script>
        const liveVideo = document.getElementById('liveVideo');
        const recordedVideo = document.getElementById('recordedVideo');
        const startRecordingBtn = document.getElementById('startRecording');
        const stopRecordingBtn = document.getElementById('stopRecording');
        const statusDiv = document.getElementById('status');
    const detectionCanvas = document.getElementById('detectionCanvas');
    const detectionCtx = detectionCanvas.getContext('2d');
    const downloadLogBtn = document.getElementById('downloadLogBtn');

        let mediaRecorder;
        let recordedChunks = [];
    let cocoSsdModel = null;
    // For tracking all objects
    let lastObjectPositions = {};
    // For logging detection events
    let detectionLog = [];

        // 1. Initialize - Get Webcam Feed and Load Model
        async function initialize() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                liveVideo.srcObject = stream;

                // Load the COCO-SSD model
                statusDiv.innerText = "Loading TensorFlow.js model...";
                cocoSsdModel = await cocoSsd.load();
                statusDiv.innerText = "Model loaded. Ready to record.";

            } catch (err) {
                console.error("Error initializing:", err);
                statusDiv.innerText = "Error accessing webcam or loading model. Please grant permissions and refresh.";
            }
        }

        initialize();

        // 2. Recording Logic
        startRecordingBtn.addEventListener('click', () => {
            recordedChunks = [];
            const stream = liveVideo.srcObject;
            mediaRecorder = new MediaRecorder(stream);

            mediaRecorder.ondataavailable = event => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                recordedVideo.src = url;
                saveVideoToIndexedDB(blob);
                detectMovementInVideo();
            };

            mediaRecorder.start();
            startRecordingBtn.disabled = true;
            stopRecordingBtn.disabled = false;
            statusDiv.innerText = "Recording...";
        });

        stopRecordingBtn.addEventListener('click', () => {
            mediaRecorder.stop();
            startRecordingBtn.disabled = false;
            stopRecordingBtn.disabled = true;
            statusDiv.innerText = "Processing video...";
        });

        // 3. Movement Detection Logic
        async function detectMovementInVideo() {
            recordedVideo.play();
            lastObjectPositions = {};
            detectionLog = [];
            downloadLogBtn.disabled = true;

            // Helper to get current video time in seconds
            function getCurrentTimestamp() {
                return recordedVideo.currentTime;
            }

            recordedVideo.addEventListener('play', () => {
                const detectFrame = async () => {
                    if (recordedVideo.paused || recordedVideo.ended) {
                        statusDiv.innerText = "Object detection finished.";
                        downloadLogBtn.disabled = false;
                        return;
                    }

                    detectionCtx.drawImage(recordedVideo, 0, 0, detectionCanvas.width, detectionCanvas.height);
                    const predictions = await cocoSsdModel.detect(detectionCanvas);

                    // Draw all bounding boxes and log detections
                    detectionCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
                    detectionCtx.drawImage(recordedVideo, 0, 0, detectionCanvas.width, detectionCanvas.height);

                    const currentDetections = {};
                    // Color palette for different object classes
                    const colorPalette = [
                        '#00FF00', '#FF0000', '#0000FF', '#FF00FF', '#00FFFF', '#FFA500', '#FFFF00', '#008000', '#800080', '#A52A2A'
                    ];
                    const classColor = {};
                    let colorIdx = 0;
                    predictions.forEach(pred => {
                        const [x, y, width, height] = pred.bbox;
                        // Assign a color per class
                        if (!classColor[pred.class]) {
                            classColor[pred.class] = colorPalette[colorIdx % colorPalette.length];
                            colorIdx++;
                        }
                        const color = classColor[pred.class];
                        // Draw bounding box
                        detectionCtx.strokeStyle = color;
                        detectionCtx.lineWidth = 2;
                        detectionCtx.strokeRect(x, y, width, height);
                        detectionCtx.font = '16px Arial';
                        detectionCtx.fillStyle = color;
                        detectionCtx.fillText(pred.class, x, y > 10 ? y - 5 : 10);

                        // Track detections for logging
                        currentDetections[pred.class] = currentDetections[pred.class] || [];
                        currentDetections[pred.class].push({
                            bbox: [x, y, width, height],
                            score: pred.score
                        });

                        // Movement tracking (simple: compare to last position)
                        if (lastObjectPositions[pred.class]) {
                            const last = lastObjectPositions[pred.class][0];
                            const dx = Math.abs(x - last.bbox[0]);
                            const dy = Math.abs(y - last.bbox[1]);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance > 10) {
                                statusDiv.innerText = `Movement Detected: ${pred.class}`;
                            }
                        }
                    });

                    // Log detection events (start/end timestamps, label, bbox)
                    Object.keys(currentDetections).forEach(label => {
                        currentDetections[label].forEach(obj => {
                            // Find if this object is already in the log (by label and bbox proximity)
                            let found = false;
                            for (let entry of detectionLog) {
                                if (entry.label === label && bboxClose(entry.bbox, obj.bbox)) {
                                    entry.end = getCurrentTimestamp();
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                detectionLog.push({
                                    label: label,
                                    start: getCurrentTimestamp(),
                                    end: getCurrentTimestamp(),
                                    bbox: obj.bbox
                                });
                            }
                        });
                    });

                    // Remove objects from log if not detected anymore (end timestamp is set)
                    detectionLog.forEach(entry => {
                        const stillDetected = currentDetections[entry.label] && currentDetections[entry.label].some(obj => bboxClose(obj.bbox, entry.bbox));
                        if (!stillDetected && entry.end === entry.start) {
                            entry.end = getCurrentTimestamp();
                        }
                    });

                    lastObjectPositions = currentDetections;

                    requestAnimationFrame(detectFrame);
                };

                // Helper: check if two bboxes are close (for tracking)
                function bboxClose(b1, b2, threshold = 30) {
                    const dx = Math.abs(b1[0] - b2[0]);
                    const dy = Math.abs(b1[1] - b2[1]);
                    return dx < threshold && dy < threshold;
                }

                detectFrame();
            });
        }

        // Download detection log as JSON
        downloadLogBtn.addEventListener('click', () => {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(detectionLog, null, 2));
            const dlAnchor = document.createElement('a');
            dlAnchor.setAttribute("href", dataStr);
            dlAnchor.setAttribute("download", "detection_log.json");
            document.body.appendChild(dlAnchor);
            dlAnchor.click();
            dlAnchor.remove();
        });


        // 4. Local Storage with IndexedDB
        function saveVideoToIndexedDB(blob) {
            const dbName = "videoDB";
            const request = indexedDB.open(dbName, 1);

            request.onupgradeneeded = event => {
                const db = event.target.result;
                db.createObjectStore("videos", { keyPath: "id", autoIncrement: true });
            };

            request.onsuccess = event => {
                const db = event.target.result;
                const transaction = db.transaction(["videos"], "readwrite");
                const store = transaction.objectStore("videos");
                store.add({ video: blob, timestamp: new Date() });

                transaction.oncomplete = () => {
                    console.log("Video saved to IndexedDB.");
                };
                transaction.onerror = (err) => {
                    console.error("Error saving video:", err);
                };
            };

            request.onerror = event => {
                console.error("Error opening IndexedDB:", event.target.errorCode);
            };
        }

    </script>
</body>
</html>